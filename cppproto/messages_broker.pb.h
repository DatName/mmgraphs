// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages_broker.proto

#ifndef PROTOBUF_INCLUDED_messages_5fbroker_2eproto
#define PROTOBUF_INCLUDED_messages_5fbroker_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "messages_generic.pb.h"
#include "order.pb.h"
#include "messages_indicators.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_messages_5fbroker_2eproto 

namespace protobuf_messages_5fbroker_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[15];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_messages_5fbroker_2eproto
namespace models {
class BalanceBody;
class BalanceBodyDefaultTypeInternal;
extern BalanceBodyDefaultTypeInternal _BalanceBody_default_instance_;
class BalanceBody_AvailableEntry_DoNotUse;
class BalanceBody_AvailableEntry_DoNotUseDefaultTypeInternal;
extern BalanceBody_AvailableEntry_DoNotUseDefaultTypeInternal _BalanceBody_AvailableEntry_DoNotUse_default_instance_;
class BalanceBody_TotalEntry_DoNotUse;
class BalanceBody_TotalEntry_DoNotUseDefaultTypeInternal;
extern BalanceBody_TotalEntry_DoNotUseDefaultTypeInternal _BalanceBody_TotalEntry_DoNotUse_default_instance_;
class InstrumentBody;
class InstrumentBodyDefaultTypeInternal;
extern InstrumentBodyDefaultTypeInternal _InstrumentBody_default_instance_;
class OpenOrdersIndicatorMessage;
class OpenOrdersIndicatorMessageDefaultTypeInternal;
extern OpenOrdersIndicatorMessageDefaultTypeInternal _OpenOrdersIndicatorMessage_default_instance_;
class PullBalancesResponse;
class PullBalancesResponseDefaultTypeInternal;
extern PullBalancesResponseDefaultTypeInternal _PullBalancesResponse_default_instance_;
class PullMarketsResponse;
class PullMarketsResponseDefaultTypeInternal;
extern PullMarketsResponseDefaultTypeInternal _PullMarketsResponse_default_instance_;
class PullMarketsResponse_MessageBody;
class PullMarketsResponse_MessageBodyDefaultTypeInternal;
extern PullMarketsResponse_MessageBodyDefaultTypeInternal _PullMarketsResponse_MessageBody_default_instance_;
class PullMarketsResponse_MessageBody_InstrumentsEntry_DoNotUse;
class PullMarketsResponse_MessageBody_InstrumentsEntry_DoNotUseDefaultTypeInternal;
extern PullMarketsResponse_MessageBody_InstrumentsEntry_DoNotUseDefaultTypeInternal _PullMarketsResponse_MessageBody_InstrumentsEntry_DoNotUse_default_instance_;
class PullOrdersResponse;
class PullOrdersResponseDefaultTypeInternal;
extern PullOrdersResponseDefaultTypeInternal _PullOrdersResponse_default_instance_;
class PushLoginResponse;
class PushLoginResponseDefaultTypeInternal;
extern PushLoginResponseDefaultTypeInternal _PushLoginResponse_default_instance_;
class PushLoginResponse_MessageBody;
class PushLoginResponse_MessageBodyDefaultTypeInternal;
extern PushLoginResponse_MessageBodyDefaultTypeInternal _PushLoginResponse_MessageBody_default_instance_;
class PushLoginResponse_MessageBody_InstrumentsEntry_DoNotUse;
class PushLoginResponse_MessageBody_InstrumentsEntry_DoNotUseDefaultTypeInternal;
extern PushLoginResponse_MessageBody_InstrumentsEntry_DoNotUseDefaultTypeInternal _PushLoginResponse_MessageBody_InstrumentsEntry_DoNotUse_default_instance_;
class PushLoginResponse_MessageBody_PositionByMarketEntry_DoNotUse;
class PushLoginResponse_MessageBody_PositionByMarketEntry_DoNotUseDefaultTypeInternal;
extern PushLoginResponse_MessageBody_PositionByMarketEntry_DoNotUseDefaultTypeInternal _PushLoginResponse_MessageBody_PositionByMarketEntry_DoNotUse_default_instance_;
class TradeIndicatorMessage;
class TradeIndicatorMessageDefaultTypeInternal;
extern TradeIndicatorMessageDefaultTypeInternal _TradeIndicatorMessage_default_instance_;
}  // namespace models
namespace google {
namespace protobuf {
template<> ::models::BalanceBody* Arena::CreateMaybeMessage<::models::BalanceBody>(Arena*);
template<> ::models::BalanceBody_AvailableEntry_DoNotUse* Arena::CreateMaybeMessage<::models::BalanceBody_AvailableEntry_DoNotUse>(Arena*);
template<> ::models::BalanceBody_TotalEntry_DoNotUse* Arena::CreateMaybeMessage<::models::BalanceBody_TotalEntry_DoNotUse>(Arena*);
template<> ::models::InstrumentBody* Arena::CreateMaybeMessage<::models::InstrumentBody>(Arena*);
template<> ::models::OpenOrdersIndicatorMessage* Arena::CreateMaybeMessage<::models::OpenOrdersIndicatorMessage>(Arena*);
template<> ::models::PullBalancesResponse* Arena::CreateMaybeMessage<::models::PullBalancesResponse>(Arena*);
template<> ::models::PullMarketsResponse* Arena::CreateMaybeMessage<::models::PullMarketsResponse>(Arena*);
template<> ::models::PullMarketsResponse_MessageBody* Arena::CreateMaybeMessage<::models::PullMarketsResponse_MessageBody>(Arena*);
template<> ::models::PullMarketsResponse_MessageBody_InstrumentsEntry_DoNotUse* Arena::CreateMaybeMessage<::models::PullMarketsResponse_MessageBody_InstrumentsEntry_DoNotUse>(Arena*);
template<> ::models::PullOrdersResponse* Arena::CreateMaybeMessage<::models::PullOrdersResponse>(Arena*);
template<> ::models::PushLoginResponse* Arena::CreateMaybeMessage<::models::PushLoginResponse>(Arena*);
template<> ::models::PushLoginResponse_MessageBody* Arena::CreateMaybeMessage<::models::PushLoginResponse_MessageBody>(Arena*);
template<> ::models::PushLoginResponse_MessageBody_InstrumentsEntry_DoNotUse* Arena::CreateMaybeMessage<::models::PushLoginResponse_MessageBody_InstrumentsEntry_DoNotUse>(Arena*);
template<> ::models::PushLoginResponse_MessageBody_PositionByMarketEntry_DoNotUse* Arena::CreateMaybeMessage<::models::PushLoginResponse_MessageBody_PositionByMarketEntry_DoNotUse>(Arena*);
template<> ::models::TradeIndicatorMessage* Arena::CreateMaybeMessage<::models::TradeIndicatorMessage>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace models {

// ===================================================================

class BalanceBody_TotalEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<BalanceBody_TotalEntry_DoNotUse, 
    ::std::string, double,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<BalanceBody_TotalEntry_DoNotUse, 
    ::std::string, double,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
    0 > SuperType;
  BalanceBody_TotalEntry_DoNotUse();
  BalanceBody_TotalEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const BalanceBody_TotalEntry_DoNotUse& other);
  static const BalanceBody_TotalEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const BalanceBody_TotalEntry_DoNotUse*>(&_BalanceBody_TotalEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class BalanceBody_AvailableEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<BalanceBody_AvailableEntry_DoNotUse, 
    ::std::string, double,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<BalanceBody_AvailableEntry_DoNotUse, 
    ::std::string, double,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
    0 > SuperType;
  BalanceBody_AvailableEntry_DoNotUse();
  BalanceBody_AvailableEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const BalanceBody_AvailableEntry_DoNotUse& other);
  static const BalanceBody_AvailableEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const BalanceBody_AvailableEntry_DoNotUse*>(&_BalanceBody_AvailableEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class BalanceBody : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:models.BalanceBody) */ {
 public:
  BalanceBody();
  virtual ~BalanceBody();

  BalanceBody(const BalanceBody& from);

  inline BalanceBody& operator=(const BalanceBody& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BalanceBody(BalanceBody&& from) noexcept
    : BalanceBody() {
    *this = ::std::move(from);
  }

  inline BalanceBody& operator=(BalanceBody&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BalanceBody& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BalanceBody* internal_default_instance() {
    return reinterpret_cast<const BalanceBody*>(
               &_BalanceBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(BalanceBody* other);
  friend void swap(BalanceBody& a, BalanceBody& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BalanceBody* New() const final {
    return CreateMaybeMessage<BalanceBody>(NULL);
  }

  BalanceBody* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BalanceBody>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BalanceBody& from);
  void MergeFrom(const BalanceBody& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BalanceBody* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, double> Total = 1;
  int total_size() const;
  void clear_total();
  static const int kTotalFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, double >&
      total() const;
  ::google::protobuf::Map< ::std::string, double >*
      mutable_total();

  // map<string, double> Available = 2;
  int available_size() const;
  void clear_available();
  static const int kAvailableFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, double >&
      available() const;
  ::google::protobuf::Map< ::std::string, double >*
      mutable_available();

  // @@protoc_insertion_point(class_scope:models.BalanceBody)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      BalanceBody_TotalEntry_DoNotUse,
      ::std::string, double,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
      0 > total_;
  ::google::protobuf::internal::MapField<
      BalanceBody_AvailableEntry_DoNotUse,
      ::std::string, double,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
      0 > available_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5fbroker_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InstrumentBody : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:models.InstrumentBody) */ {
 public:
  InstrumentBody();
  virtual ~InstrumentBody();

  InstrumentBody(const InstrumentBody& from);

  inline InstrumentBody& operator=(const InstrumentBody& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InstrumentBody(InstrumentBody&& from) noexcept
    : InstrumentBody() {
    *this = ::std::move(from);
  }

  inline InstrumentBody& operator=(InstrumentBody&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InstrumentBody& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InstrumentBody* internal_default_instance() {
    return reinterpret_cast<const InstrumentBody*>(
               &_InstrumentBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(InstrumentBody* other);
  friend void swap(InstrumentBody& a, InstrumentBody& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InstrumentBody* New() const final {
    return CreateMaybeMessage<InstrumentBody>(NULL);
  }

  InstrumentBody* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InstrumentBody>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InstrumentBody& from);
  void MergeFrom(const InstrumentBody& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstrumentBody* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Base = 1;
  void clear_base();
  static const int kBaseFieldNumber = 1;
  const ::std::string& base() const;
  void set_base(const ::std::string& value);
  #if LANG_CXX11
  void set_base(::std::string&& value);
  #endif
  void set_base(const char* value);
  void set_base(const char* value, size_t size);
  ::std::string* mutable_base();
  ::std::string* release_base();
  void set_allocated_base(::std::string* base);

  // string Quote = 2;
  void clear_quote();
  static const int kQuoteFieldNumber = 2;
  const ::std::string& quote() const;
  void set_quote(const ::std::string& value);
  #if LANG_CXX11
  void set_quote(::std::string&& value);
  #endif
  void set_quote(const char* value);
  void set_quote(const char* value, size_t size);
  ::std::string* mutable_quote();
  ::std::string* release_quote();
  void set_allocated_quote(::std::string* quote);

  // string Maker = 7;
  void clear_maker();
  static const int kMakerFieldNumber = 7;
  const ::std::string& maker() const;
  void set_maker(const ::std::string& value);
  #if LANG_CXX11
  void set_maker(::std::string&& value);
  #endif
  void set_maker(const char* value);
  void set_maker(const char* value, size_t size);
  ::std::string* mutable_maker();
  ::std::string* release_maker();
  void set_allocated_maker(::std::string* maker);

  // string Taker = 8;
  void clear_taker();
  static const int kTakerFieldNumber = 8;
  const ::std::string& taker() const;
  void set_taker(const ::std::string& value);
  #if LANG_CXX11
  void set_taker(::std::string&& value);
  #endif
  void set_taker(const char* value);
  void set_taker(const char* value, size_t size);
  ::std::string* mutable_taker();
  ::std::string* release_taker();
  void set_allocated_taker(::std::string* taker);

  // double BaseMin = 3;
  void clear_basemin();
  static const int kBaseMinFieldNumber = 3;
  double basemin() const;
  void set_basemin(double value);

  // double QuoteMin = 5;
  void clear_quotemin();
  static const int kQuoteMinFieldNumber = 5;
  double quotemin() const;
  void set_quotemin(double value);

  // int32 BasePrecision = 4;
  void clear_baseprecision();
  static const int kBasePrecisionFieldNumber = 4;
  ::google::protobuf::int32 baseprecision() const;
  void set_baseprecision(::google::protobuf::int32 value);

  // int32 QuotePrecision = 6;
  void clear_quoteprecision();
  static const int kQuotePrecisionFieldNumber = 6;
  ::google::protobuf::int32 quoteprecision() const;
  void set_quoteprecision(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:models.InstrumentBody)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr base_;
  ::google::protobuf::internal::ArenaStringPtr quote_;
  ::google::protobuf::internal::ArenaStringPtr maker_;
  ::google::protobuf::internal::ArenaStringPtr taker_;
  double basemin_;
  double quotemin_;
  ::google::protobuf::int32 baseprecision_;
  ::google::protobuf::int32 quoteprecision_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5fbroker_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PushLoginResponse_MessageBody_InstrumentsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<PushLoginResponse_MessageBody_InstrumentsEntry_DoNotUse, 
    ::std::string, ::models::InstrumentBody,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<PushLoginResponse_MessageBody_InstrumentsEntry_DoNotUse, 
    ::std::string, ::models::InstrumentBody,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  PushLoginResponse_MessageBody_InstrumentsEntry_DoNotUse();
  PushLoginResponse_MessageBody_InstrumentsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const PushLoginResponse_MessageBody_InstrumentsEntry_DoNotUse& other);
  static const PushLoginResponse_MessageBody_InstrumentsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PushLoginResponse_MessageBody_InstrumentsEntry_DoNotUse*>(&_PushLoginResponse_MessageBody_InstrumentsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class PushLoginResponse_MessageBody_PositionByMarketEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<PushLoginResponse_MessageBody_PositionByMarketEntry_DoNotUse, 
    ::std::string, double,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<PushLoginResponse_MessageBody_PositionByMarketEntry_DoNotUse, 
    ::std::string, double,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
    0 > SuperType;
  PushLoginResponse_MessageBody_PositionByMarketEntry_DoNotUse();
  PushLoginResponse_MessageBody_PositionByMarketEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const PushLoginResponse_MessageBody_PositionByMarketEntry_DoNotUse& other);
  static const PushLoginResponse_MessageBody_PositionByMarketEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PushLoginResponse_MessageBody_PositionByMarketEntry_DoNotUse*>(&_PushLoginResponse_MessageBody_PositionByMarketEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class PushLoginResponse_MessageBody : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:models.PushLoginResponse.MessageBody) */ {
 public:
  PushLoginResponse_MessageBody();
  virtual ~PushLoginResponse_MessageBody();

  PushLoginResponse_MessageBody(const PushLoginResponse_MessageBody& from);

  inline PushLoginResponse_MessageBody& operator=(const PushLoginResponse_MessageBody& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PushLoginResponse_MessageBody(PushLoginResponse_MessageBody&& from) noexcept
    : PushLoginResponse_MessageBody() {
    *this = ::std::move(from);
  }

  inline PushLoginResponse_MessageBody& operator=(PushLoginResponse_MessageBody&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PushLoginResponse_MessageBody& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PushLoginResponse_MessageBody* internal_default_instance() {
    return reinterpret_cast<const PushLoginResponse_MessageBody*>(
               &_PushLoginResponse_MessageBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(PushLoginResponse_MessageBody* other);
  friend void swap(PushLoginResponse_MessageBody& a, PushLoginResponse_MessageBody& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PushLoginResponse_MessageBody* New() const final {
    return CreateMaybeMessage<PushLoginResponse_MessageBody>(NULL);
  }

  PushLoginResponse_MessageBody* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PushLoginResponse_MessageBody>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PushLoginResponse_MessageBody& from);
  void MergeFrom(const PushLoginResponse_MessageBody& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushLoginResponse_MessageBody* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .models.InstrumentBody> Instruments = 2;
  int instruments_size() const;
  void clear_instruments();
  static const int kInstrumentsFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::models::InstrumentBody >&
      instruments() const;
  ::google::protobuf::Map< ::std::string, ::models::InstrumentBody >*
      mutable_instruments();

  // map<string, double> PositionByMarket = 3;
  int positionbymarket_size() const;
  void clear_positionbymarket();
  static const int kPositionByMarketFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, double >&
      positionbymarket() const;
  ::google::protobuf::Map< ::std::string, double >*
      mutable_positionbymarket();

  // .models.BalanceBody Balance = 1;
  bool has_balance() const;
  void clear_balance();
  static const int kBalanceFieldNumber = 1;
  private:
  const ::models::BalanceBody& _internal_balance() const;
  public:
  const ::models::BalanceBody& balance() const;
  ::models::BalanceBody* release_balance();
  ::models::BalanceBody* mutable_balance();
  void set_allocated_balance(::models::BalanceBody* balance);

  // @@protoc_insertion_point(class_scope:models.PushLoginResponse.MessageBody)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      PushLoginResponse_MessageBody_InstrumentsEntry_DoNotUse,
      ::std::string, ::models::InstrumentBody,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > instruments_;
  ::google::protobuf::internal::MapField<
      PushLoginResponse_MessageBody_PositionByMarketEntry_DoNotUse,
      ::std::string, double,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
      0 > positionbymarket_;
  ::models::BalanceBody* balance_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5fbroker_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PushLoginResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:models.PushLoginResponse) */ {
 public:
  PushLoginResponse();
  virtual ~PushLoginResponse();

  PushLoginResponse(const PushLoginResponse& from);

  inline PushLoginResponse& operator=(const PushLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PushLoginResponse(PushLoginResponse&& from) noexcept
    : PushLoginResponse() {
    *this = ::std::move(from);
  }

  inline PushLoginResponse& operator=(PushLoginResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PushLoginResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PushLoginResponse* internal_default_instance() {
    return reinterpret_cast<const PushLoginResponse*>(
               &_PushLoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(PushLoginResponse* other);
  friend void swap(PushLoginResponse& a, PushLoginResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PushLoginResponse* New() const final {
    return CreateMaybeMessage<PushLoginResponse>(NULL);
  }

  PushLoginResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PushLoginResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PushLoginResponse& from);
  void MergeFrom(const PushLoginResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushLoginResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PushLoginResponse_MessageBody MessageBody;

  // accessors -------------------------------------------------------

  // .models.MessageHeader Header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::models::MessageHeader& _internal_header() const;
  public:
  const ::models::MessageHeader& header() const;
  ::models::MessageHeader* release_header();
  ::models::MessageHeader* mutable_header();
  void set_allocated_header(::models::MessageHeader* header);

  // .models.PushLoginResponse.MessageBody Body = 2;
  bool has_body() const;
  void clear_body();
  static const int kBodyFieldNumber = 2;
  private:
  const ::models::PushLoginResponse_MessageBody& _internal_body() const;
  public:
  const ::models::PushLoginResponse_MessageBody& body() const;
  ::models::PushLoginResponse_MessageBody* release_body();
  ::models::PushLoginResponse_MessageBody* mutable_body();
  void set_allocated_body(::models::PushLoginResponse_MessageBody* body);

  // @@protoc_insertion_point(class_scope:models.PushLoginResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::models::MessageHeader* header_;
  ::models::PushLoginResponse_MessageBody* body_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5fbroker_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PullOrdersResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:models.PullOrdersResponse) */ {
 public:
  PullOrdersResponse();
  virtual ~PullOrdersResponse();

  PullOrdersResponse(const PullOrdersResponse& from);

  inline PullOrdersResponse& operator=(const PullOrdersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PullOrdersResponse(PullOrdersResponse&& from) noexcept
    : PullOrdersResponse() {
    *this = ::std::move(from);
  }

  inline PullOrdersResponse& operator=(PullOrdersResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PullOrdersResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PullOrdersResponse* internal_default_instance() {
    return reinterpret_cast<const PullOrdersResponse*>(
               &_PullOrdersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(PullOrdersResponse* other);
  friend void swap(PullOrdersResponse& a, PullOrdersResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PullOrdersResponse* New() const final {
    return CreateMaybeMessage<PullOrdersResponse>(NULL);
  }

  PullOrdersResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PullOrdersResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PullOrdersResponse& from);
  void MergeFrom(const PullOrdersResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PullOrdersResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .models.Order Body = 2;
  int body_size() const;
  void clear_body();
  static const int kBodyFieldNumber = 2;
  ::models::Order* mutable_body(int index);
  ::google::protobuf::RepeatedPtrField< ::models::Order >*
      mutable_body();
  const ::models::Order& body(int index) const;
  ::models::Order* add_body();
  const ::google::protobuf::RepeatedPtrField< ::models::Order >&
      body() const;

  // .models.MessageHeader Header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::models::MessageHeader& _internal_header() const;
  public:
  const ::models::MessageHeader& header() const;
  ::models::MessageHeader* release_header();
  ::models::MessageHeader* mutable_header();
  void set_allocated_header(::models::MessageHeader* header);

  // @@protoc_insertion_point(class_scope:models.PullOrdersResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::models::Order > body_;
  ::models::MessageHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5fbroker_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PullBalancesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:models.PullBalancesResponse) */ {
 public:
  PullBalancesResponse();
  virtual ~PullBalancesResponse();

  PullBalancesResponse(const PullBalancesResponse& from);

  inline PullBalancesResponse& operator=(const PullBalancesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PullBalancesResponse(PullBalancesResponse&& from) noexcept
    : PullBalancesResponse() {
    *this = ::std::move(from);
  }

  inline PullBalancesResponse& operator=(PullBalancesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PullBalancesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PullBalancesResponse* internal_default_instance() {
    return reinterpret_cast<const PullBalancesResponse*>(
               &_PullBalancesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(PullBalancesResponse* other);
  friend void swap(PullBalancesResponse& a, PullBalancesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PullBalancesResponse* New() const final {
    return CreateMaybeMessage<PullBalancesResponse>(NULL);
  }

  PullBalancesResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PullBalancesResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PullBalancesResponse& from);
  void MergeFrom(const PullBalancesResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PullBalancesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .models.MessageHeader Header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::models::MessageHeader& _internal_header() const;
  public:
  const ::models::MessageHeader& header() const;
  ::models::MessageHeader* release_header();
  ::models::MessageHeader* mutable_header();
  void set_allocated_header(::models::MessageHeader* header);

  // .models.BalanceBody Body = 2;
  bool has_body() const;
  void clear_body();
  static const int kBodyFieldNumber = 2;
  private:
  const ::models::BalanceBody& _internal_body() const;
  public:
  const ::models::BalanceBody& body() const;
  ::models::BalanceBody* release_body();
  ::models::BalanceBody* mutable_body();
  void set_allocated_body(::models::BalanceBody* body);

  // @@protoc_insertion_point(class_scope:models.PullBalancesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::models::MessageHeader* header_;
  ::models::BalanceBody* body_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5fbroker_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PullMarketsResponse_MessageBody_InstrumentsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<PullMarketsResponse_MessageBody_InstrumentsEntry_DoNotUse, 
    ::std::string, ::models::InstrumentBody,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<PullMarketsResponse_MessageBody_InstrumentsEntry_DoNotUse, 
    ::std::string, ::models::InstrumentBody,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  PullMarketsResponse_MessageBody_InstrumentsEntry_DoNotUse();
  PullMarketsResponse_MessageBody_InstrumentsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const PullMarketsResponse_MessageBody_InstrumentsEntry_DoNotUse& other);
  static const PullMarketsResponse_MessageBody_InstrumentsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PullMarketsResponse_MessageBody_InstrumentsEntry_DoNotUse*>(&_PullMarketsResponse_MessageBody_InstrumentsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class PullMarketsResponse_MessageBody : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:models.PullMarketsResponse.MessageBody) */ {
 public:
  PullMarketsResponse_MessageBody();
  virtual ~PullMarketsResponse_MessageBody();

  PullMarketsResponse_MessageBody(const PullMarketsResponse_MessageBody& from);

  inline PullMarketsResponse_MessageBody& operator=(const PullMarketsResponse_MessageBody& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PullMarketsResponse_MessageBody(PullMarketsResponse_MessageBody&& from) noexcept
    : PullMarketsResponse_MessageBody() {
    *this = ::std::move(from);
  }

  inline PullMarketsResponse_MessageBody& operator=(PullMarketsResponse_MessageBody&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PullMarketsResponse_MessageBody& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PullMarketsResponse_MessageBody* internal_default_instance() {
    return reinterpret_cast<const PullMarketsResponse_MessageBody*>(
               &_PullMarketsResponse_MessageBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(PullMarketsResponse_MessageBody* other);
  friend void swap(PullMarketsResponse_MessageBody& a, PullMarketsResponse_MessageBody& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PullMarketsResponse_MessageBody* New() const final {
    return CreateMaybeMessage<PullMarketsResponse_MessageBody>(NULL);
  }

  PullMarketsResponse_MessageBody* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PullMarketsResponse_MessageBody>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PullMarketsResponse_MessageBody& from);
  void MergeFrom(const PullMarketsResponse_MessageBody& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PullMarketsResponse_MessageBody* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .models.InstrumentBody> Instruments = 1;
  int instruments_size() const;
  void clear_instruments();
  static const int kInstrumentsFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::models::InstrumentBody >&
      instruments() const;
  ::google::protobuf::Map< ::std::string, ::models::InstrumentBody >*
      mutable_instruments();

  // @@protoc_insertion_point(class_scope:models.PullMarketsResponse.MessageBody)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      PullMarketsResponse_MessageBody_InstrumentsEntry_DoNotUse,
      ::std::string, ::models::InstrumentBody,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > instruments_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5fbroker_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PullMarketsResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:models.PullMarketsResponse) */ {
 public:
  PullMarketsResponse();
  virtual ~PullMarketsResponse();

  PullMarketsResponse(const PullMarketsResponse& from);

  inline PullMarketsResponse& operator=(const PullMarketsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PullMarketsResponse(PullMarketsResponse&& from) noexcept
    : PullMarketsResponse() {
    *this = ::std::move(from);
  }

  inline PullMarketsResponse& operator=(PullMarketsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PullMarketsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PullMarketsResponse* internal_default_instance() {
    return reinterpret_cast<const PullMarketsResponse*>(
               &_PullMarketsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(PullMarketsResponse* other);
  friend void swap(PullMarketsResponse& a, PullMarketsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PullMarketsResponse* New() const final {
    return CreateMaybeMessage<PullMarketsResponse>(NULL);
  }

  PullMarketsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PullMarketsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PullMarketsResponse& from);
  void MergeFrom(const PullMarketsResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PullMarketsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PullMarketsResponse_MessageBody MessageBody;

  // accessors -------------------------------------------------------

  // .models.MessageHeader Header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::models::MessageHeader& _internal_header() const;
  public:
  const ::models::MessageHeader& header() const;
  ::models::MessageHeader* release_header();
  ::models::MessageHeader* mutable_header();
  void set_allocated_header(::models::MessageHeader* header);

  // .models.PullMarketsResponse.MessageBody Body = 2;
  bool has_body() const;
  void clear_body();
  static const int kBodyFieldNumber = 2;
  private:
  const ::models::PullMarketsResponse_MessageBody& _internal_body() const;
  public:
  const ::models::PullMarketsResponse_MessageBody& body() const;
  ::models::PullMarketsResponse_MessageBody* release_body();
  ::models::PullMarketsResponse_MessageBody* mutable_body();
  void set_allocated_body(::models::PullMarketsResponse_MessageBody* body);

  // @@protoc_insertion_point(class_scope:models.PullMarketsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::models::MessageHeader* header_;
  ::models::PullMarketsResponse_MessageBody* body_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5fbroker_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TradeIndicatorMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:models.TradeIndicatorMessage) */ {
 public:
  TradeIndicatorMessage();
  virtual ~TradeIndicatorMessage();

  TradeIndicatorMessage(const TradeIndicatorMessage& from);

  inline TradeIndicatorMessage& operator=(const TradeIndicatorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TradeIndicatorMessage(TradeIndicatorMessage&& from) noexcept
    : TradeIndicatorMessage() {
    *this = ::std::move(from);
  }

  inline TradeIndicatorMessage& operator=(TradeIndicatorMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TradeIndicatorMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TradeIndicatorMessage* internal_default_instance() {
    return reinterpret_cast<const TradeIndicatorMessage*>(
               &_TradeIndicatorMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(TradeIndicatorMessage* other);
  friend void swap(TradeIndicatorMessage& a, TradeIndicatorMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TradeIndicatorMessage* New() const final {
    return CreateMaybeMessage<TradeIndicatorMessage>(NULL);
  }

  TradeIndicatorMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TradeIndicatorMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TradeIndicatorMessage& from);
  void MergeFrom(const TradeIndicatorMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradeIndicatorMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .models.TradeIndicator Body = 2;
  int body_size() const;
  void clear_body();
  static const int kBodyFieldNumber = 2;
  ::models::TradeIndicator* mutable_body(int index);
  ::google::protobuf::RepeatedPtrField< ::models::TradeIndicator >*
      mutable_body();
  const ::models::TradeIndicator& body(int index) const;
  ::models::TradeIndicator* add_body();
  const ::google::protobuf::RepeatedPtrField< ::models::TradeIndicator >&
      body() const;

  // .models.MessageHeader Header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::models::MessageHeader& _internal_header() const;
  public:
  const ::models::MessageHeader& header() const;
  ::models::MessageHeader* release_header();
  ::models::MessageHeader* mutable_header();
  void set_allocated_header(::models::MessageHeader* header);

  // @@protoc_insertion_point(class_scope:models.TradeIndicatorMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::models::TradeIndicator > body_;
  ::models::MessageHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5fbroker_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OpenOrdersIndicatorMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:models.OpenOrdersIndicatorMessage) */ {
 public:
  OpenOrdersIndicatorMessage();
  virtual ~OpenOrdersIndicatorMessage();

  OpenOrdersIndicatorMessage(const OpenOrdersIndicatorMessage& from);

  inline OpenOrdersIndicatorMessage& operator=(const OpenOrdersIndicatorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OpenOrdersIndicatorMessage(OpenOrdersIndicatorMessage&& from) noexcept
    : OpenOrdersIndicatorMessage() {
    *this = ::std::move(from);
  }

  inline OpenOrdersIndicatorMessage& operator=(OpenOrdersIndicatorMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenOrdersIndicatorMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpenOrdersIndicatorMessage* internal_default_instance() {
    return reinterpret_cast<const OpenOrdersIndicatorMessage*>(
               &_OpenOrdersIndicatorMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(OpenOrdersIndicatorMessage* other);
  friend void swap(OpenOrdersIndicatorMessage& a, OpenOrdersIndicatorMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OpenOrdersIndicatorMessage* New() const final {
    return CreateMaybeMessage<OpenOrdersIndicatorMessage>(NULL);
  }

  OpenOrdersIndicatorMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OpenOrdersIndicatorMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OpenOrdersIndicatorMessage& from);
  void MergeFrom(const OpenOrdersIndicatorMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenOrdersIndicatorMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .models.Order Body = 2;
  int body_size() const;
  void clear_body();
  static const int kBodyFieldNumber = 2;
  ::models::Order* mutable_body(int index);
  ::google::protobuf::RepeatedPtrField< ::models::Order >*
      mutable_body();
  const ::models::Order& body(int index) const;
  ::models::Order* add_body();
  const ::google::protobuf::RepeatedPtrField< ::models::Order >&
      body() const;

  // .models.MessageHeader Header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::models::MessageHeader& _internal_header() const;
  public:
  const ::models::MessageHeader& header() const;
  ::models::MessageHeader* release_header();
  ::models::MessageHeader* mutable_header();
  void set_allocated_header(::models::MessageHeader* header);

  // @@protoc_insertion_point(class_scope:models.OpenOrdersIndicatorMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::models::Order > body_;
  ::models::MessageHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5fbroker_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// BalanceBody

// map<string, double> Total = 1;
inline int BalanceBody::total_size() const {
  return total_.size();
}
inline void BalanceBody::clear_total() {
  total_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, double >&
BalanceBody::total() const {
  // @@protoc_insertion_point(field_map:models.BalanceBody.Total)
  return total_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, double >*
BalanceBody::mutable_total() {
  // @@protoc_insertion_point(field_mutable_map:models.BalanceBody.Total)
  return total_.MutableMap();
}

// map<string, double> Available = 2;
inline int BalanceBody::available_size() const {
  return available_.size();
}
inline void BalanceBody::clear_available() {
  available_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, double >&
BalanceBody::available() const {
  // @@protoc_insertion_point(field_map:models.BalanceBody.Available)
  return available_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, double >*
BalanceBody::mutable_available() {
  // @@protoc_insertion_point(field_mutable_map:models.BalanceBody.Available)
  return available_.MutableMap();
}

// -------------------------------------------------------------------

// InstrumentBody

// string Base = 1;
inline void InstrumentBody::clear_base() {
  base_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InstrumentBody::base() const {
  // @@protoc_insertion_point(field_get:models.InstrumentBody.Base)
  return base_.GetNoArena();
}
inline void InstrumentBody::set_base(const ::std::string& value) {
  
  base_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:models.InstrumentBody.Base)
}
#if LANG_CXX11
inline void InstrumentBody::set_base(::std::string&& value) {
  
  base_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:models.InstrumentBody.Base)
}
#endif
inline void InstrumentBody::set_base(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  base_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:models.InstrumentBody.Base)
}
inline void InstrumentBody::set_base(const char* value, size_t size) {
  
  base_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:models.InstrumentBody.Base)
}
inline ::std::string* InstrumentBody::mutable_base() {
  
  // @@protoc_insertion_point(field_mutable:models.InstrumentBody.Base)
  return base_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstrumentBody::release_base() {
  // @@protoc_insertion_point(field_release:models.InstrumentBody.Base)
  
  return base_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstrumentBody::set_allocated_base(::std::string* base) {
  if (base != NULL) {
    
  } else {
    
  }
  base_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), base);
  // @@protoc_insertion_point(field_set_allocated:models.InstrumentBody.Base)
}

// string Quote = 2;
inline void InstrumentBody::clear_quote() {
  quote_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InstrumentBody::quote() const {
  // @@protoc_insertion_point(field_get:models.InstrumentBody.Quote)
  return quote_.GetNoArena();
}
inline void InstrumentBody::set_quote(const ::std::string& value) {
  
  quote_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:models.InstrumentBody.Quote)
}
#if LANG_CXX11
inline void InstrumentBody::set_quote(::std::string&& value) {
  
  quote_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:models.InstrumentBody.Quote)
}
#endif
inline void InstrumentBody::set_quote(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  quote_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:models.InstrumentBody.Quote)
}
inline void InstrumentBody::set_quote(const char* value, size_t size) {
  
  quote_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:models.InstrumentBody.Quote)
}
inline ::std::string* InstrumentBody::mutable_quote() {
  
  // @@protoc_insertion_point(field_mutable:models.InstrumentBody.Quote)
  return quote_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstrumentBody::release_quote() {
  // @@protoc_insertion_point(field_release:models.InstrumentBody.Quote)
  
  return quote_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstrumentBody::set_allocated_quote(::std::string* quote) {
  if (quote != NULL) {
    
  } else {
    
  }
  quote_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), quote);
  // @@protoc_insertion_point(field_set_allocated:models.InstrumentBody.Quote)
}

// double BaseMin = 3;
inline void InstrumentBody::clear_basemin() {
  basemin_ = 0;
}
inline double InstrumentBody::basemin() const {
  // @@protoc_insertion_point(field_get:models.InstrumentBody.BaseMin)
  return basemin_;
}
inline void InstrumentBody::set_basemin(double value) {
  
  basemin_ = value;
  // @@protoc_insertion_point(field_set:models.InstrumentBody.BaseMin)
}

// int32 BasePrecision = 4;
inline void InstrumentBody::clear_baseprecision() {
  baseprecision_ = 0;
}
inline ::google::protobuf::int32 InstrumentBody::baseprecision() const {
  // @@protoc_insertion_point(field_get:models.InstrumentBody.BasePrecision)
  return baseprecision_;
}
inline void InstrumentBody::set_baseprecision(::google::protobuf::int32 value) {
  
  baseprecision_ = value;
  // @@protoc_insertion_point(field_set:models.InstrumentBody.BasePrecision)
}

// double QuoteMin = 5;
inline void InstrumentBody::clear_quotemin() {
  quotemin_ = 0;
}
inline double InstrumentBody::quotemin() const {
  // @@protoc_insertion_point(field_get:models.InstrumentBody.QuoteMin)
  return quotemin_;
}
inline void InstrumentBody::set_quotemin(double value) {
  
  quotemin_ = value;
  // @@protoc_insertion_point(field_set:models.InstrumentBody.QuoteMin)
}

// int32 QuotePrecision = 6;
inline void InstrumentBody::clear_quoteprecision() {
  quoteprecision_ = 0;
}
inline ::google::protobuf::int32 InstrumentBody::quoteprecision() const {
  // @@protoc_insertion_point(field_get:models.InstrumentBody.QuotePrecision)
  return quoteprecision_;
}
inline void InstrumentBody::set_quoteprecision(::google::protobuf::int32 value) {
  
  quoteprecision_ = value;
  // @@protoc_insertion_point(field_set:models.InstrumentBody.QuotePrecision)
}

// string Maker = 7;
inline void InstrumentBody::clear_maker() {
  maker_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InstrumentBody::maker() const {
  // @@protoc_insertion_point(field_get:models.InstrumentBody.Maker)
  return maker_.GetNoArena();
}
inline void InstrumentBody::set_maker(const ::std::string& value) {
  
  maker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:models.InstrumentBody.Maker)
}
#if LANG_CXX11
inline void InstrumentBody::set_maker(::std::string&& value) {
  
  maker_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:models.InstrumentBody.Maker)
}
#endif
inline void InstrumentBody::set_maker(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  maker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:models.InstrumentBody.Maker)
}
inline void InstrumentBody::set_maker(const char* value, size_t size) {
  
  maker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:models.InstrumentBody.Maker)
}
inline ::std::string* InstrumentBody::mutable_maker() {
  
  // @@protoc_insertion_point(field_mutable:models.InstrumentBody.Maker)
  return maker_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstrumentBody::release_maker() {
  // @@protoc_insertion_point(field_release:models.InstrumentBody.Maker)
  
  return maker_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstrumentBody::set_allocated_maker(::std::string* maker) {
  if (maker != NULL) {
    
  } else {
    
  }
  maker_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), maker);
  // @@protoc_insertion_point(field_set_allocated:models.InstrumentBody.Maker)
}

// string Taker = 8;
inline void InstrumentBody::clear_taker() {
  taker_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InstrumentBody::taker() const {
  // @@protoc_insertion_point(field_get:models.InstrumentBody.Taker)
  return taker_.GetNoArena();
}
inline void InstrumentBody::set_taker(const ::std::string& value) {
  
  taker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:models.InstrumentBody.Taker)
}
#if LANG_CXX11
inline void InstrumentBody::set_taker(::std::string&& value) {
  
  taker_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:models.InstrumentBody.Taker)
}
#endif
inline void InstrumentBody::set_taker(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  taker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:models.InstrumentBody.Taker)
}
inline void InstrumentBody::set_taker(const char* value, size_t size) {
  
  taker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:models.InstrumentBody.Taker)
}
inline ::std::string* InstrumentBody::mutable_taker() {
  
  // @@protoc_insertion_point(field_mutable:models.InstrumentBody.Taker)
  return taker_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstrumentBody::release_taker() {
  // @@protoc_insertion_point(field_release:models.InstrumentBody.Taker)
  
  return taker_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstrumentBody::set_allocated_taker(::std::string* taker) {
  if (taker != NULL) {
    
  } else {
    
  }
  taker_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), taker);
  // @@protoc_insertion_point(field_set_allocated:models.InstrumentBody.Taker)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PushLoginResponse_MessageBody

// .models.BalanceBody Balance = 1;
inline bool PushLoginResponse_MessageBody::has_balance() const {
  return this != internal_default_instance() && balance_ != NULL;
}
inline void PushLoginResponse_MessageBody::clear_balance() {
  if (GetArenaNoVirtual() == NULL && balance_ != NULL) {
    delete balance_;
  }
  balance_ = NULL;
}
inline const ::models::BalanceBody& PushLoginResponse_MessageBody::_internal_balance() const {
  return *balance_;
}
inline const ::models::BalanceBody& PushLoginResponse_MessageBody::balance() const {
  const ::models::BalanceBody* p = balance_;
  // @@protoc_insertion_point(field_get:models.PushLoginResponse.MessageBody.Balance)
  return p != NULL ? *p : *reinterpret_cast<const ::models::BalanceBody*>(
      &::models::_BalanceBody_default_instance_);
}
inline ::models::BalanceBody* PushLoginResponse_MessageBody::release_balance() {
  // @@protoc_insertion_point(field_release:models.PushLoginResponse.MessageBody.Balance)
  
  ::models::BalanceBody* temp = balance_;
  balance_ = NULL;
  return temp;
}
inline ::models::BalanceBody* PushLoginResponse_MessageBody::mutable_balance() {
  
  if (balance_ == NULL) {
    auto* p = CreateMaybeMessage<::models::BalanceBody>(GetArenaNoVirtual());
    balance_ = p;
  }
  // @@protoc_insertion_point(field_mutable:models.PushLoginResponse.MessageBody.Balance)
  return balance_;
}
inline void PushLoginResponse_MessageBody::set_allocated_balance(::models::BalanceBody* balance) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete balance_;
  }
  if (balance) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      balance = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, balance, submessage_arena);
    }
    
  } else {
    
  }
  balance_ = balance;
  // @@protoc_insertion_point(field_set_allocated:models.PushLoginResponse.MessageBody.Balance)
}

// map<string, .models.InstrumentBody> Instruments = 2;
inline int PushLoginResponse_MessageBody::instruments_size() const {
  return instruments_.size();
}
inline void PushLoginResponse_MessageBody::clear_instruments() {
  instruments_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::models::InstrumentBody >&
PushLoginResponse_MessageBody::instruments() const {
  // @@protoc_insertion_point(field_map:models.PushLoginResponse.MessageBody.Instruments)
  return instruments_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::models::InstrumentBody >*
PushLoginResponse_MessageBody::mutable_instruments() {
  // @@protoc_insertion_point(field_mutable_map:models.PushLoginResponse.MessageBody.Instruments)
  return instruments_.MutableMap();
}

// map<string, double> PositionByMarket = 3;
inline int PushLoginResponse_MessageBody::positionbymarket_size() const {
  return positionbymarket_.size();
}
inline void PushLoginResponse_MessageBody::clear_positionbymarket() {
  positionbymarket_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, double >&
PushLoginResponse_MessageBody::positionbymarket() const {
  // @@protoc_insertion_point(field_map:models.PushLoginResponse.MessageBody.PositionByMarket)
  return positionbymarket_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, double >*
PushLoginResponse_MessageBody::mutable_positionbymarket() {
  // @@protoc_insertion_point(field_mutable_map:models.PushLoginResponse.MessageBody.PositionByMarket)
  return positionbymarket_.MutableMap();
}

// -------------------------------------------------------------------

// PushLoginResponse

// .models.MessageHeader Header = 1;
inline bool PushLoginResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::models::MessageHeader& PushLoginResponse::_internal_header() const {
  return *header_;
}
inline const ::models::MessageHeader& PushLoginResponse::header() const {
  const ::models::MessageHeader* p = header_;
  // @@protoc_insertion_point(field_get:models.PushLoginResponse.Header)
  return p != NULL ? *p : *reinterpret_cast<const ::models::MessageHeader*>(
      &::models::_MessageHeader_default_instance_);
}
inline ::models::MessageHeader* PushLoginResponse::release_header() {
  // @@protoc_insertion_point(field_release:models.PushLoginResponse.Header)
  
  ::models::MessageHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::models::MessageHeader* PushLoginResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::models::MessageHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:models.PushLoginResponse.Header)
  return header_;
}
inline void PushLoginResponse::set_allocated_header(::models::MessageHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:models.PushLoginResponse.Header)
}

// .models.PushLoginResponse.MessageBody Body = 2;
inline bool PushLoginResponse::has_body() const {
  return this != internal_default_instance() && body_ != NULL;
}
inline void PushLoginResponse::clear_body() {
  if (GetArenaNoVirtual() == NULL && body_ != NULL) {
    delete body_;
  }
  body_ = NULL;
}
inline const ::models::PushLoginResponse_MessageBody& PushLoginResponse::_internal_body() const {
  return *body_;
}
inline const ::models::PushLoginResponse_MessageBody& PushLoginResponse::body() const {
  const ::models::PushLoginResponse_MessageBody* p = body_;
  // @@protoc_insertion_point(field_get:models.PushLoginResponse.Body)
  return p != NULL ? *p : *reinterpret_cast<const ::models::PushLoginResponse_MessageBody*>(
      &::models::_PushLoginResponse_MessageBody_default_instance_);
}
inline ::models::PushLoginResponse_MessageBody* PushLoginResponse::release_body() {
  // @@protoc_insertion_point(field_release:models.PushLoginResponse.Body)
  
  ::models::PushLoginResponse_MessageBody* temp = body_;
  body_ = NULL;
  return temp;
}
inline ::models::PushLoginResponse_MessageBody* PushLoginResponse::mutable_body() {
  
  if (body_ == NULL) {
    auto* p = CreateMaybeMessage<::models::PushLoginResponse_MessageBody>(GetArenaNoVirtual());
    body_ = p;
  }
  // @@protoc_insertion_point(field_mutable:models.PushLoginResponse.Body)
  return body_;
}
inline void PushLoginResponse::set_allocated_body(::models::PushLoginResponse_MessageBody* body) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete body_;
  }
  if (body) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      body = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, body, submessage_arena);
    }
    
  } else {
    
  }
  body_ = body;
  // @@protoc_insertion_point(field_set_allocated:models.PushLoginResponse.Body)
}

// -------------------------------------------------------------------

// PullOrdersResponse

// .models.MessageHeader Header = 1;
inline bool PullOrdersResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::models::MessageHeader& PullOrdersResponse::_internal_header() const {
  return *header_;
}
inline const ::models::MessageHeader& PullOrdersResponse::header() const {
  const ::models::MessageHeader* p = header_;
  // @@protoc_insertion_point(field_get:models.PullOrdersResponse.Header)
  return p != NULL ? *p : *reinterpret_cast<const ::models::MessageHeader*>(
      &::models::_MessageHeader_default_instance_);
}
inline ::models::MessageHeader* PullOrdersResponse::release_header() {
  // @@protoc_insertion_point(field_release:models.PullOrdersResponse.Header)
  
  ::models::MessageHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::models::MessageHeader* PullOrdersResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::models::MessageHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:models.PullOrdersResponse.Header)
  return header_;
}
inline void PullOrdersResponse::set_allocated_header(::models::MessageHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:models.PullOrdersResponse.Header)
}

// repeated .models.Order Body = 2;
inline int PullOrdersResponse::body_size() const {
  return body_.size();
}
inline ::models::Order* PullOrdersResponse::mutable_body(int index) {
  // @@protoc_insertion_point(field_mutable:models.PullOrdersResponse.Body)
  return body_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::models::Order >*
PullOrdersResponse::mutable_body() {
  // @@protoc_insertion_point(field_mutable_list:models.PullOrdersResponse.Body)
  return &body_;
}
inline const ::models::Order& PullOrdersResponse::body(int index) const {
  // @@protoc_insertion_point(field_get:models.PullOrdersResponse.Body)
  return body_.Get(index);
}
inline ::models::Order* PullOrdersResponse::add_body() {
  // @@protoc_insertion_point(field_add:models.PullOrdersResponse.Body)
  return body_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::models::Order >&
PullOrdersResponse::body() const {
  // @@protoc_insertion_point(field_list:models.PullOrdersResponse.Body)
  return body_;
}

// -------------------------------------------------------------------

// PullBalancesResponse

// .models.MessageHeader Header = 1;
inline bool PullBalancesResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::models::MessageHeader& PullBalancesResponse::_internal_header() const {
  return *header_;
}
inline const ::models::MessageHeader& PullBalancesResponse::header() const {
  const ::models::MessageHeader* p = header_;
  // @@protoc_insertion_point(field_get:models.PullBalancesResponse.Header)
  return p != NULL ? *p : *reinterpret_cast<const ::models::MessageHeader*>(
      &::models::_MessageHeader_default_instance_);
}
inline ::models::MessageHeader* PullBalancesResponse::release_header() {
  // @@protoc_insertion_point(field_release:models.PullBalancesResponse.Header)
  
  ::models::MessageHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::models::MessageHeader* PullBalancesResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::models::MessageHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:models.PullBalancesResponse.Header)
  return header_;
}
inline void PullBalancesResponse::set_allocated_header(::models::MessageHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:models.PullBalancesResponse.Header)
}

// .models.BalanceBody Body = 2;
inline bool PullBalancesResponse::has_body() const {
  return this != internal_default_instance() && body_ != NULL;
}
inline void PullBalancesResponse::clear_body() {
  if (GetArenaNoVirtual() == NULL && body_ != NULL) {
    delete body_;
  }
  body_ = NULL;
}
inline const ::models::BalanceBody& PullBalancesResponse::_internal_body() const {
  return *body_;
}
inline const ::models::BalanceBody& PullBalancesResponse::body() const {
  const ::models::BalanceBody* p = body_;
  // @@protoc_insertion_point(field_get:models.PullBalancesResponse.Body)
  return p != NULL ? *p : *reinterpret_cast<const ::models::BalanceBody*>(
      &::models::_BalanceBody_default_instance_);
}
inline ::models::BalanceBody* PullBalancesResponse::release_body() {
  // @@protoc_insertion_point(field_release:models.PullBalancesResponse.Body)
  
  ::models::BalanceBody* temp = body_;
  body_ = NULL;
  return temp;
}
inline ::models::BalanceBody* PullBalancesResponse::mutable_body() {
  
  if (body_ == NULL) {
    auto* p = CreateMaybeMessage<::models::BalanceBody>(GetArenaNoVirtual());
    body_ = p;
  }
  // @@protoc_insertion_point(field_mutable:models.PullBalancesResponse.Body)
  return body_;
}
inline void PullBalancesResponse::set_allocated_body(::models::BalanceBody* body) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete body_;
  }
  if (body) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      body = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, body, submessage_arena);
    }
    
  } else {
    
  }
  body_ = body;
  // @@protoc_insertion_point(field_set_allocated:models.PullBalancesResponse.Body)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PullMarketsResponse_MessageBody

// map<string, .models.InstrumentBody> Instruments = 1;
inline int PullMarketsResponse_MessageBody::instruments_size() const {
  return instruments_.size();
}
inline void PullMarketsResponse_MessageBody::clear_instruments() {
  instruments_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::models::InstrumentBody >&
PullMarketsResponse_MessageBody::instruments() const {
  // @@protoc_insertion_point(field_map:models.PullMarketsResponse.MessageBody.Instruments)
  return instruments_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::models::InstrumentBody >*
PullMarketsResponse_MessageBody::mutable_instruments() {
  // @@protoc_insertion_point(field_mutable_map:models.PullMarketsResponse.MessageBody.Instruments)
  return instruments_.MutableMap();
}

// -------------------------------------------------------------------

// PullMarketsResponse

// .models.MessageHeader Header = 1;
inline bool PullMarketsResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::models::MessageHeader& PullMarketsResponse::_internal_header() const {
  return *header_;
}
inline const ::models::MessageHeader& PullMarketsResponse::header() const {
  const ::models::MessageHeader* p = header_;
  // @@protoc_insertion_point(field_get:models.PullMarketsResponse.Header)
  return p != NULL ? *p : *reinterpret_cast<const ::models::MessageHeader*>(
      &::models::_MessageHeader_default_instance_);
}
inline ::models::MessageHeader* PullMarketsResponse::release_header() {
  // @@protoc_insertion_point(field_release:models.PullMarketsResponse.Header)
  
  ::models::MessageHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::models::MessageHeader* PullMarketsResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::models::MessageHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:models.PullMarketsResponse.Header)
  return header_;
}
inline void PullMarketsResponse::set_allocated_header(::models::MessageHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:models.PullMarketsResponse.Header)
}

// .models.PullMarketsResponse.MessageBody Body = 2;
inline bool PullMarketsResponse::has_body() const {
  return this != internal_default_instance() && body_ != NULL;
}
inline void PullMarketsResponse::clear_body() {
  if (GetArenaNoVirtual() == NULL && body_ != NULL) {
    delete body_;
  }
  body_ = NULL;
}
inline const ::models::PullMarketsResponse_MessageBody& PullMarketsResponse::_internal_body() const {
  return *body_;
}
inline const ::models::PullMarketsResponse_MessageBody& PullMarketsResponse::body() const {
  const ::models::PullMarketsResponse_MessageBody* p = body_;
  // @@protoc_insertion_point(field_get:models.PullMarketsResponse.Body)
  return p != NULL ? *p : *reinterpret_cast<const ::models::PullMarketsResponse_MessageBody*>(
      &::models::_PullMarketsResponse_MessageBody_default_instance_);
}
inline ::models::PullMarketsResponse_MessageBody* PullMarketsResponse::release_body() {
  // @@protoc_insertion_point(field_release:models.PullMarketsResponse.Body)
  
  ::models::PullMarketsResponse_MessageBody* temp = body_;
  body_ = NULL;
  return temp;
}
inline ::models::PullMarketsResponse_MessageBody* PullMarketsResponse::mutable_body() {
  
  if (body_ == NULL) {
    auto* p = CreateMaybeMessage<::models::PullMarketsResponse_MessageBody>(GetArenaNoVirtual());
    body_ = p;
  }
  // @@protoc_insertion_point(field_mutable:models.PullMarketsResponse.Body)
  return body_;
}
inline void PullMarketsResponse::set_allocated_body(::models::PullMarketsResponse_MessageBody* body) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete body_;
  }
  if (body) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      body = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, body, submessage_arena);
    }
    
  } else {
    
  }
  body_ = body;
  // @@protoc_insertion_point(field_set_allocated:models.PullMarketsResponse.Body)
}

// -------------------------------------------------------------------

// TradeIndicatorMessage

// .models.MessageHeader Header = 1;
inline bool TradeIndicatorMessage::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::models::MessageHeader& TradeIndicatorMessage::_internal_header() const {
  return *header_;
}
inline const ::models::MessageHeader& TradeIndicatorMessage::header() const {
  const ::models::MessageHeader* p = header_;
  // @@protoc_insertion_point(field_get:models.TradeIndicatorMessage.Header)
  return p != NULL ? *p : *reinterpret_cast<const ::models::MessageHeader*>(
      &::models::_MessageHeader_default_instance_);
}
inline ::models::MessageHeader* TradeIndicatorMessage::release_header() {
  // @@protoc_insertion_point(field_release:models.TradeIndicatorMessage.Header)
  
  ::models::MessageHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::models::MessageHeader* TradeIndicatorMessage::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::models::MessageHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:models.TradeIndicatorMessage.Header)
  return header_;
}
inline void TradeIndicatorMessage::set_allocated_header(::models::MessageHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:models.TradeIndicatorMessage.Header)
}

// repeated .models.TradeIndicator Body = 2;
inline int TradeIndicatorMessage::body_size() const {
  return body_.size();
}
inline ::models::TradeIndicator* TradeIndicatorMessage::mutable_body(int index) {
  // @@protoc_insertion_point(field_mutable:models.TradeIndicatorMessage.Body)
  return body_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::models::TradeIndicator >*
TradeIndicatorMessage::mutable_body() {
  // @@protoc_insertion_point(field_mutable_list:models.TradeIndicatorMessage.Body)
  return &body_;
}
inline const ::models::TradeIndicator& TradeIndicatorMessage::body(int index) const {
  // @@protoc_insertion_point(field_get:models.TradeIndicatorMessage.Body)
  return body_.Get(index);
}
inline ::models::TradeIndicator* TradeIndicatorMessage::add_body() {
  // @@protoc_insertion_point(field_add:models.TradeIndicatorMessage.Body)
  return body_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::models::TradeIndicator >&
TradeIndicatorMessage::body() const {
  // @@protoc_insertion_point(field_list:models.TradeIndicatorMessage.Body)
  return body_;
}

// -------------------------------------------------------------------

// OpenOrdersIndicatorMessage

// .models.MessageHeader Header = 1;
inline bool OpenOrdersIndicatorMessage::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::models::MessageHeader& OpenOrdersIndicatorMessage::_internal_header() const {
  return *header_;
}
inline const ::models::MessageHeader& OpenOrdersIndicatorMessage::header() const {
  const ::models::MessageHeader* p = header_;
  // @@protoc_insertion_point(field_get:models.OpenOrdersIndicatorMessage.Header)
  return p != NULL ? *p : *reinterpret_cast<const ::models::MessageHeader*>(
      &::models::_MessageHeader_default_instance_);
}
inline ::models::MessageHeader* OpenOrdersIndicatorMessage::release_header() {
  // @@protoc_insertion_point(field_release:models.OpenOrdersIndicatorMessage.Header)
  
  ::models::MessageHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::models::MessageHeader* OpenOrdersIndicatorMessage::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::models::MessageHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:models.OpenOrdersIndicatorMessage.Header)
  return header_;
}
inline void OpenOrdersIndicatorMessage::set_allocated_header(::models::MessageHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:models.OpenOrdersIndicatorMessage.Header)
}

// repeated .models.Order Body = 2;
inline int OpenOrdersIndicatorMessage::body_size() const {
  return body_.size();
}
inline ::models::Order* OpenOrdersIndicatorMessage::mutable_body(int index) {
  // @@protoc_insertion_point(field_mutable:models.OpenOrdersIndicatorMessage.Body)
  return body_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::models::Order >*
OpenOrdersIndicatorMessage::mutable_body() {
  // @@protoc_insertion_point(field_mutable_list:models.OpenOrdersIndicatorMessage.Body)
  return &body_;
}
inline const ::models::Order& OpenOrdersIndicatorMessage::body(int index) const {
  // @@protoc_insertion_point(field_get:models.OpenOrdersIndicatorMessage.Body)
  return body_.Get(index);
}
inline ::models::Order* OpenOrdersIndicatorMessage::add_body() {
  // @@protoc_insertion_point(field_add:models.OpenOrdersIndicatorMessage.Body)
  return body_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::models::Order >&
OpenOrdersIndicatorMessage::body() const {
  // @@protoc_insertion_point(field_list:models.OpenOrdersIndicatorMessage.Body)
  return body_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace models

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_messages_5fbroker_2eproto
