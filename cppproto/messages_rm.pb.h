// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages_rm.proto

#ifndef PROTOBUF_INCLUDED_messages_5frm_2eproto
#define PROTOBUF_INCLUDED_messages_5frm_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "messages_generic.pb.h"
#include "order.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_messages_5frm_2eproto 

namespace protobuf_messages_5frm_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_messages_5frm_2eproto
namespace models {
class AddRequest;
class AddRequestDefaultTypeInternal;
extern AddRequestDefaultTypeInternal _AddRequest_default_instance_;
class Approval;
class ApprovalDefaultTypeInternal;
extern ApprovalDefaultTypeInternal _Approval_default_instance_;
class ApprovedAdd;
class ApprovedAddDefaultTypeInternal;
extern ApprovedAddDefaultTypeInternal _ApprovedAdd_default_instance_;
class ApprovedCancel;
class ApprovedCancelDefaultTypeInternal;
extern ApprovedCancelDefaultTypeInternal _ApprovedCancel_default_instance_;
class CancelRequest;
class CancelRequestDefaultTypeInternal;
extern CancelRequestDefaultTypeInternal _CancelRequest_default_instance_;
class Empty;
class EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class RobotSwitchState;
class RobotSwitchStateDefaultTypeInternal;
extern RobotSwitchStateDefaultTypeInternal _RobotSwitchState_default_instance_;
class RobotSwitchState_MessageBody;
class RobotSwitchState_MessageBodyDefaultTypeInternal;
extern RobotSwitchState_MessageBodyDefaultTypeInternal _RobotSwitchState_MessageBody_default_instance_;
}  // namespace models
namespace google {
namespace protobuf {
template<> ::models::AddRequest* Arena::CreateMaybeMessage<::models::AddRequest>(Arena*);
template<> ::models::Approval* Arena::CreateMaybeMessage<::models::Approval>(Arena*);
template<> ::models::ApprovedAdd* Arena::CreateMaybeMessage<::models::ApprovedAdd>(Arena*);
template<> ::models::ApprovedCancel* Arena::CreateMaybeMessage<::models::ApprovedCancel>(Arena*);
template<> ::models::CancelRequest* Arena::CreateMaybeMessage<::models::CancelRequest>(Arena*);
template<> ::models::Empty* Arena::CreateMaybeMessage<::models::Empty>(Arena*);
template<> ::models::RobotSwitchState* Arena::CreateMaybeMessage<::models::RobotSwitchState>(Arena*);
template<> ::models::RobotSwitchState_MessageBody* Arena::CreateMaybeMessage<::models::RobotSwitchState_MessageBody>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace models {

enum RobotStatus {
  STOPPED = 0,
  LAUNCHED = 1,
  PAUSED = 2,
  CLOSING = 3,
  RobotStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RobotStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RobotStatus_IsValid(int value);
const RobotStatus RobotStatus_MIN = STOPPED;
const RobotStatus RobotStatus_MAX = CLOSING;
const int RobotStatus_ARRAYSIZE = RobotStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* RobotStatus_descriptor();
inline const ::std::string& RobotStatus_Name(RobotStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    RobotStatus_descriptor(), value);
}
inline bool RobotStatus_Parse(
    const ::std::string& name, RobotStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RobotStatus>(
    RobotStatus_descriptor(), name, value);
}
// ===================================================================

class RobotSwitchState_MessageBody : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:models.RobotSwitchState.MessageBody) */ {
 public:
  RobotSwitchState_MessageBody();
  virtual ~RobotSwitchState_MessageBody();

  RobotSwitchState_MessageBody(const RobotSwitchState_MessageBody& from);

  inline RobotSwitchState_MessageBody& operator=(const RobotSwitchState_MessageBody& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RobotSwitchState_MessageBody(RobotSwitchState_MessageBody&& from) noexcept
    : RobotSwitchState_MessageBody() {
    *this = ::std::move(from);
  }

  inline RobotSwitchState_MessageBody& operator=(RobotSwitchState_MessageBody&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotSwitchState_MessageBody& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotSwitchState_MessageBody* internal_default_instance() {
    return reinterpret_cast<const RobotSwitchState_MessageBody*>(
               &_RobotSwitchState_MessageBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(RobotSwitchState_MessageBody* other);
  friend void swap(RobotSwitchState_MessageBody& a, RobotSwitchState_MessageBody& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RobotSwitchState_MessageBody* New() const final {
    return CreateMaybeMessage<RobotSwitchState_MessageBody>(NULL);
  }

  RobotSwitchState_MessageBody* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RobotSwitchState_MessageBody>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RobotSwitchState_MessageBody& from);
  void MergeFrom(const RobotSwitchState_MessageBody& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotSwitchState_MessageBody* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string RobotID = 1;
  void clear_robotid();
  static const int kRobotIDFieldNumber = 1;
  const ::std::string& robotid() const;
  void set_robotid(const ::std::string& value);
  #if LANG_CXX11
  void set_robotid(::std::string&& value);
  #endif
  void set_robotid(const char* value);
  void set_robotid(const char* value, size_t size);
  ::std::string* mutable_robotid();
  ::std::string* release_robotid();
  void set_allocated_robotid(::std::string* robotid);

  // .models.RobotStatus Status = 2;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::models::RobotStatus status() const;
  void set_status(::models::RobotStatus value);

  // @@protoc_insertion_point(class_scope:models.RobotSwitchState.MessageBody)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr robotid_;
  int status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5frm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RobotSwitchState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:models.RobotSwitchState) */ {
 public:
  RobotSwitchState();
  virtual ~RobotSwitchState();

  RobotSwitchState(const RobotSwitchState& from);

  inline RobotSwitchState& operator=(const RobotSwitchState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RobotSwitchState(RobotSwitchState&& from) noexcept
    : RobotSwitchState() {
    *this = ::std::move(from);
  }

  inline RobotSwitchState& operator=(RobotSwitchState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotSwitchState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotSwitchState* internal_default_instance() {
    return reinterpret_cast<const RobotSwitchState*>(
               &_RobotSwitchState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RobotSwitchState* other);
  friend void swap(RobotSwitchState& a, RobotSwitchState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RobotSwitchState* New() const final {
    return CreateMaybeMessage<RobotSwitchState>(NULL);
  }

  RobotSwitchState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RobotSwitchState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RobotSwitchState& from);
  void MergeFrom(const RobotSwitchState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotSwitchState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RobotSwitchState_MessageBody MessageBody;

  // accessors -------------------------------------------------------

  // .models.MessageHeader Header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::models::MessageHeader& _internal_header() const;
  public:
  const ::models::MessageHeader& header() const;
  ::models::MessageHeader* release_header();
  ::models::MessageHeader* mutable_header();
  void set_allocated_header(::models::MessageHeader* header);

  // .models.RobotSwitchState.MessageBody Body = 2;
  bool has_body() const;
  void clear_body();
  static const int kBodyFieldNumber = 2;
  private:
  const ::models::RobotSwitchState_MessageBody& _internal_body() const;
  public:
  const ::models::RobotSwitchState_MessageBody& body() const;
  ::models::RobotSwitchState_MessageBody* release_body();
  ::models::RobotSwitchState_MessageBody* mutable_body();
  void set_allocated_body(::models::RobotSwitchState_MessageBody* body);

  // @@protoc_insertion_point(class_scope:models.RobotSwitchState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::models::MessageHeader* header_;
  ::models::RobotSwitchState_MessageBody* body_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5frm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Empty : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:models.Empty) */ {
 public:
  Empty();
  virtual ~Empty();

  Empty(const Empty& from);

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(Empty&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Empty& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Empty* other);
  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Empty* New() const final {
    return CreateMaybeMessage<Empty>(NULL);
  }

  Empty* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Empty& from);
  void MergeFrom(const Empty& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Empty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:models.Empty)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5frm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Approval : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:models.Approval) */ {
 public:
  Approval();
  virtual ~Approval();

  Approval(const Approval& from);

  inline Approval& operator=(const Approval& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Approval(Approval&& from) noexcept
    : Approval() {
    *this = ::std::move(from);
  }

  inline Approval& operator=(Approval&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Approval& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Approval* internal_default_instance() {
    return reinterpret_cast<const Approval*>(
               &_Approval_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Approval* other);
  friend void swap(Approval& a, Approval& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Approval* New() const final {
    return CreateMaybeMessage<Approval>(NULL);
  }

  Approval* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Approval>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Approval& from);
  void MergeFrom(const Approval& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Approval* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool approved = 1;
  void clear_approved();
  static const int kApprovedFieldNumber = 1;
  bool approved() const;
  void set_approved(bool value);

  // @@protoc_insertion_point(class_scope:models.Approval)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool approved_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5frm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:models.AddRequest) */ {
 public:
  AddRequest();
  virtual ~AddRequest();

  AddRequest(const AddRequest& from);

  inline AddRequest& operator=(const AddRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddRequest(AddRequest&& from) noexcept
    : AddRequest() {
    *this = ::std::move(from);
  }

  inline AddRequest& operator=(AddRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddRequest* internal_default_instance() {
    return reinterpret_cast<const AddRequest*>(
               &_AddRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(AddRequest* other);
  friend void swap(AddRequest& a, AddRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddRequest* New() const final {
    return CreateMaybeMessage<AddRequest>(NULL);
  }

  AddRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddRequest& from);
  void MergeFrom(const AddRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string RobotID = 1;
  void clear_robotid();
  static const int kRobotIDFieldNumber = 1;
  const ::std::string& robotid() const;
  void set_robotid(const ::std::string& value);
  #if LANG_CXX11
  void set_robotid(::std::string&& value);
  #endif
  void set_robotid(const char* value);
  void set_robotid(const char* value, size_t size);
  ::std::string* mutable_robotid();
  ::std::string* release_robotid();
  void set_allocated_robotid(::std::string* robotid);

  // .models.NewOrder AddingOrder = 2;
  bool has_addingorder() const;
  void clear_addingorder();
  static const int kAddingOrderFieldNumber = 2;
  private:
  const ::models::NewOrder& _internal_addingorder() const;
  public:
  const ::models::NewOrder& addingorder() const;
  ::models::NewOrder* release_addingorder();
  ::models::NewOrder* mutable_addingorder();
  void set_allocated_addingorder(::models::NewOrder* addingorder);

  // @@protoc_insertion_point(class_scope:models.AddRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr robotid_;
  ::models::NewOrder* addingorder_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5frm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ApprovedAdd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:models.ApprovedAdd) */ {
 public:
  ApprovedAdd();
  virtual ~ApprovedAdd();

  ApprovedAdd(const ApprovedAdd& from);

  inline ApprovedAdd& operator=(const ApprovedAdd& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ApprovedAdd(ApprovedAdd&& from) noexcept
    : ApprovedAdd() {
    *this = ::std::move(from);
  }

  inline ApprovedAdd& operator=(ApprovedAdd&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ApprovedAdd& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ApprovedAdd* internal_default_instance() {
    return reinterpret_cast<const ApprovedAdd*>(
               &_ApprovedAdd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ApprovedAdd* other);
  friend void swap(ApprovedAdd& a, ApprovedAdd& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ApprovedAdd* New() const final {
    return CreateMaybeMessage<ApprovedAdd>(NULL);
  }

  ApprovedAdd* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ApprovedAdd>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ApprovedAdd& from);
  void MergeFrom(const ApprovedAdd& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApprovedAdd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .models.AddRequest AddedRequest = 1;
  bool has_addedrequest() const;
  void clear_addedrequest();
  static const int kAddedRequestFieldNumber = 1;
  private:
  const ::models::AddRequest& _internal_addedrequest() const;
  public:
  const ::models::AddRequest& addedrequest() const;
  ::models::AddRequest* release_addedrequest();
  ::models::AddRequest* mutable_addedrequest();
  void set_allocated_addedrequest(::models::AddRequest* addedrequest);

  // bool approved = 2;
  void clear_approved();
  static const int kApprovedFieldNumber = 2;
  bool approved() const;
  void set_approved(bool value);

  // @@protoc_insertion_point(class_scope:models.ApprovedAdd)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::models::AddRequest* addedrequest_;
  bool approved_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5frm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CancelRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:models.CancelRequest) */ {
 public:
  CancelRequest();
  virtual ~CancelRequest();

  CancelRequest(const CancelRequest& from);

  inline CancelRequest& operator=(const CancelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CancelRequest(CancelRequest&& from) noexcept
    : CancelRequest() {
    *this = ::std::move(from);
  }

  inline CancelRequest& operator=(CancelRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CancelRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CancelRequest* internal_default_instance() {
    return reinterpret_cast<const CancelRequest*>(
               &_CancelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(CancelRequest* other);
  friend void swap(CancelRequest& a, CancelRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CancelRequest* New() const final {
    return CreateMaybeMessage<CancelRequest>(NULL);
  }

  CancelRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CancelRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CancelRequest& from);
  void MergeFrom(const CancelRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string RobotID = 1;
  void clear_robotid();
  static const int kRobotIDFieldNumber = 1;
  const ::std::string& robotid() const;
  void set_robotid(const ::std::string& value);
  #if LANG_CXX11
  void set_robotid(::std::string&& value);
  #endif
  void set_robotid(const char* value);
  void set_robotid(const char* value, size_t size);
  ::std::string* mutable_robotid();
  ::std::string* release_robotid();
  void set_allocated_robotid(::std::string* robotid);

  // .models.CancelOrder CancellingOrder = 2;
  bool has_cancellingorder() const;
  void clear_cancellingorder();
  static const int kCancellingOrderFieldNumber = 2;
  private:
  const ::models::CancelOrder& _internal_cancellingorder() const;
  public:
  const ::models::CancelOrder& cancellingorder() const;
  ::models::CancelOrder* release_cancellingorder();
  ::models::CancelOrder* mutable_cancellingorder();
  void set_allocated_cancellingorder(::models::CancelOrder* cancellingorder);

  // @@protoc_insertion_point(class_scope:models.CancelRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr robotid_;
  ::models::CancelOrder* cancellingorder_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5frm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ApprovedCancel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:models.ApprovedCancel) */ {
 public:
  ApprovedCancel();
  virtual ~ApprovedCancel();

  ApprovedCancel(const ApprovedCancel& from);

  inline ApprovedCancel& operator=(const ApprovedCancel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ApprovedCancel(ApprovedCancel&& from) noexcept
    : ApprovedCancel() {
    *this = ::std::move(from);
  }

  inline ApprovedCancel& operator=(ApprovedCancel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ApprovedCancel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ApprovedCancel* internal_default_instance() {
    return reinterpret_cast<const ApprovedCancel*>(
               &_ApprovedCancel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ApprovedCancel* other);
  friend void swap(ApprovedCancel& a, ApprovedCancel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ApprovedCancel* New() const final {
    return CreateMaybeMessage<ApprovedCancel>(NULL);
  }

  ApprovedCancel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ApprovedCancel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ApprovedCancel& from);
  void MergeFrom(const ApprovedCancel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApprovedCancel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .models.CancelRequest CancelledRequest = 1;
  bool has_cancelledrequest() const;
  void clear_cancelledrequest();
  static const int kCancelledRequestFieldNumber = 1;
  private:
  const ::models::CancelRequest& _internal_cancelledrequest() const;
  public:
  const ::models::CancelRequest& cancelledrequest() const;
  ::models::CancelRequest* release_cancelledrequest();
  ::models::CancelRequest* mutable_cancelledrequest();
  void set_allocated_cancelledrequest(::models::CancelRequest* cancelledrequest);

  // bool approved = 2;
  void clear_approved();
  static const int kApprovedFieldNumber = 2;
  bool approved() const;
  void set_approved(bool value);

  // @@protoc_insertion_point(class_scope:models.ApprovedCancel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::models::CancelRequest* cancelledrequest_;
  bool approved_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5frm_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RobotSwitchState_MessageBody

// string RobotID = 1;
inline void RobotSwitchState_MessageBody::clear_robotid() {
  robotid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RobotSwitchState_MessageBody::robotid() const {
  // @@protoc_insertion_point(field_get:models.RobotSwitchState.MessageBody.RobotID)
  return robotid_.GetNoArena();
}
inline void RobotSwitchState_MessageBody::set_robotid(const ::std::string& value) {
  
  robotid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:models.RobotSwitchState.MessageBody.RobotID)
}
#if LANG_CXX11
inline void RobotSwitchState_MessageBody::set_robotid(::std::string&& value) {
  
  robotid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:models.RobotSwitchState.MessageBody.RobotID)
}
#endif
inline void RobotSwitchState_MessageBody::set_robotid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  robotid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:models.RobotSwitchState.MessageBody.RobotID)
}
inline void RobotSwitchState_MessageBody::set_robotid(const char* value, size_t size) {
  
  robotid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:models.RobotSwitchState.MessageBody.RobotID)
}
inline ::std::string* RobotSwitchState_MessageBody::mutable_robotid() {
  
  // @@protoc_insertion_point(field_mutable:models.RobotSwitchState.MessageBody.RobotID)
  return robotid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RobotSwitchState_MessageBody::release_robotid() {
  // @@protoc_insertion_point(field_release:models.RobotSwitchState.MessageBody.RobotID)
  
  return robotid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RobotSwitchState_MessageBody::set_allocated_robotid(::std::string* robotid) {
  if (robotid != NULL) {
    
  } else {
    
  }
  robotid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), robotid);
  // @@protoc_insertion_point(field_set_allocated:models.RobotSwitchState.MessageBody.RobotID)
}

// .models.RobotStatus Status = 2;
inline void RobotSwitchState_MessageBody::clear_status() {
  status_ = 0;
}
inline ::models::RobotStatus RobotSwitchState_MessageBody::status() const {
  // @@protoc_insertion_point(field_get:models.RobotSwitchState.MessageBody.Status)
  return static_cast< ::models::RobotStatus >(status_);
}
inline void RobotSwitchState_MessageBody::set_status(::models::RobotStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:models.RobotSwitchState.MessageBody.Status)
}

// -------------------------------------------------------------------

// RobotSwitchState

// .models.MessageHeader Header = 1;
inline bool RobotSwitchState::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::models::MessageHeader& RobotSwitchState::_internal_header() const {
  return *header_;
}
inline const ::models::MessageHeader& RobotSwitchState::header() const {
  const ::models::MessageHeader* p = header_;
  // @@protoc_insertion_point(field_get:models.RobotSwitchState.Header)
  return p != NULL ? *p : *reinterpret_cast<const ::models::MessageHeader*>(
      &::models::_MessageHeader_default_instance_);
}
inline ::models::MessageHeader* RobotSwitchState::release_header() {
  // @@protoc_insertion_point(field_release:models.RobotSwitchState.Header)
  
  ::models::MessageHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::models::MessageHeader* RobotSwitchState::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::models::MessageHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:models.RobotSwitchState.Header)
  return header_;
}
inline void RobotSwitchState::set_allocated_header(::models::MessageHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:models.RobotSwitchState.Header)
}

// .models.RobotSwitchState.MessageBody Body = 2;
inline bool RobotSwitchState::has_body() const {
  return this != internal_default_instance() && body_ != NULL;
}
inline void RobotSwitchState::clear_body() {
  if (GetArenaNoVirtual() == NULL && body_ != NULL) {
    delete body_;
  }
  body_ = NULL;
}
inline const ::models::RobotSwitchState_MessageBody& RobotSwitchState::_internal_body() const {
  return *body_;
}
inline const ::models::RobotSwitchState_MessageBody& RobotSwitchState::body() const {
  const ::models::RobotSwitchState_MessageBody* p = body_;
  // @@protoc_insertion_point(field_get:models.RobotSwitchState.Body)
  return p != NULL ? *p : *reinterpret_cast<const ::models::RobotSwitchState_MessageBody*>(
      &::models::_RobotSwitchState_MessageBody_default_instance_);
}
inline ::models::RobotSwitchState_MessageBody* RobotSwitchState::release_body() {
  // @@protoc_insertion_point(field_release:models.RobotSwitchState.Body)
  
  ::models::RobotSwitchState_MessageBody* temp = body_;
  body_ = NULL;
  return temp;
}
inline ::models::RobotSwitchState_MessageBody* RobotSwitchState::mutable_body() {
  
  if (body_ == NULL) {
    auto* p = CreateMaybeMessage<::models::RobotSwitchState_MessageBody>(GetArenaNoVirtual());
    body_ = p;
  }
  // @@protoc_insertion_point(field_mutable:models.RobotSwitchState.Body)
  return body_;
}
inline void RobotSwitchState::set_allocated_body(::models::RobotSwitchState_MessageBody* body) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete body_;
  }
  if (body) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      body = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, body, submessage_arena);
    }
    
  } else {
    
  }
  body_ = body;
  // @@protoc_insertion_point(field_set_allocated:models.RobotSwitchState.Body)
}

// -------------------------------------------------------------------

// Empty

// -------------------------------------------------------------------

// Approval

// bool approved = 1;
inline void Approval::clear_approved() {
  approved_ = false;
}
inline bool Approval::approved() const {
  // @@protoc_insertion_point(field_get:models.Approval.approved)
  return approved_;
}
inline void Approval::set_approved(bool value) {
  
  approved_ = value;
  // @@protoc_insertion_point(field_set:models.Approval.approved)
}

// -------------------------------------------------------------------

// AddRequest

// string RobotID = 1;
inline void AddRequest::clear_robotid() {
  robotid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AddRequest::robotid() const {
  // @@protoc_insertion_point(field_get:models.AddRequest.RobotID)
  return robotid_.GetNoArena();
}
inline void AddRequest::set_robotid(const ::std::string& value) {
  
  robotid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:models.AddRequest.RobotID)
}
#if LANG_CXX11
inline void AddRequest::set_robotid(::std::string&& value) {
  
  robotid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:models.AddRequest.RobotID)
}
#endif
inline void AddRequest::set_robotid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  robotid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:models.AddRequest.RobotID)
}
inline void AddRequest::set_robotid(const char* value, size_t size) {
  
  robotid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:models.AddRequest.RobotID)
}
inline ::std::string* AddRequest::mutable_robotid() {
  
  // @@protoc_insertion_point(field_mutable:models.AddRequest.RobotID)
  return robotid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AddRequest::release_robotid() {
  // @@protoc_insertion_point(field_release:models.AddRequest.RobotID)
  
  return robotid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddRequest::set_allocated_robotid(::std::string* robotid) {
  if (robotid != NULL) {
    
  } else {
    
  }
  robotid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), robotid);
  // @@protoc_insertion_point(field_set_allocated:models.AddRequest.RobotID)
}

// .models.NewOrder AddingOrder = 2;
inline bool AddRequest::has_addingorder() const {
  return this != internal_default_instance() && addingorder_ != NULL;
}
inline const ::models::NewOrder& AddRequest::_internal_addingorder() const {
  return *addingorder_;
}
inline const ::models::NewOrder& AddRequest::addingorder() const {
  const ::models::NewOrder* p = addingorder_;
  // @@protoc_insertion_point(field_get:models.AddRequest.AddingOrder)
  return p != NULL ? *p : *reinterpret_cast<const ::models::NewOrder*>(
      &::models::_NewOrder_default_instance_);
}
inline ::models::NewOrder* AddRequest::release_addingorder() {
  // @@protoc_insertion_point(field_release:models.AddRequest.AddingOrder)
  
  ::models::NewOrder* temp = addingorder_;
  addingorder_ = NULL;
  return temp;
}
inline ::models::NewOrder* AddRequest::mutable_addingorder() {
  
  if (addingorder_ == NULL) {
    auto* p = CreateMaybeMessage<::models::NewOrder>(GetArenaNoVirtual());
    addingorder_ = p;
  }
  // @@protoc_insertion_point(field_mutable:models.AddRequest.AddingOrder)
  return addingorder_;
}
inline void AddRequest::set_allocated_addingorder(::models::NewOrder* addingorder) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(addingorder_);
  }
  if (addingorder) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      addingorder = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, addingorder, submessage_arena);
    }
    
  } else {
    
  }
  addingorder_ = addingorder;
  // @@protoc_insertion_point(field_set_allocated:models.AddRequest.AddingOrder)
}

// -------------------------------------------------------------------

// ApprovedAdd

// .models.AddRequest AddedRequest = 1;
inline bool ApprovedAdd::has_addedrequest() const {
  return this != internal_default_instance() && addedrequest_ != NULL;
}
inline void ApprovedAdd::clear_addedrequest() {
  if (GetArenaNoVirtual() == NULL && addedrequest_ != NULL) {
    delete addedrequest_;
  }
  addedrequest_ = NULL;
}
inline const ::models::AddRequest& ApprovedAdd::_internal_addedrequest() const {
  return *addedrequest_;
}
inline const ::models::AddRequest& ApprovedAdd::addedrequest() const {
  const ::models::AddRequest* p = addedrequest_;
  // @@protoc_insertion_point(field_get:models.ApprovedAdd.AddedRequest)
  return p != NULL ? *p : *reinterpret_cast<const ::models::AddRequest*>(
      &::models::_AddRequest_default_instance_);
}
inline ::models::AddRequest* ApprovedAdd::release_addedrequest() {
  // @@protoc_insertion_point(field_release:models.ApprovedAdd.AddedRequest)
  
  ::models::AddRequest* temp = addedrequest_;
  addedrequest_ = NULL;
  return temp;
}
inline ::models::AddRequest* ApprovedAdd::mutable_addedrequest() {
  
  if (addedrequest_ == NULL) {
    auto* p = CreateMaybeMessage<::models::AddRequest>(GetArenaNoVirtual());
    addedrequest_ = p;
  }
  // @@protoc_insertion_point(field_mutable:models.ApprovedAdd.AddedRequest)
  return addedrequest_;
}
inline void ApprovedAdd::set_allocated_addedrequest(::models::AddRequest* addedrequest) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete addedrequest_;
  }
  if (addedrequest) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      addedrequest = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, addedrequest, submessage_arena);
    }
    
  } else {
    
  }
  addedrequest_ = addedrequest;
  // @@protoc_insertion_point(field_set_allocated:models.ApprovedAdd.AddedRequest)
}

// bool approved = 2;
inline void ApprovedAdd::clear_approved() {
  approved_ = false;
}
inline bool ApprovedAdd::approved() const {
  // @@protoc_insertion_point(field_get:models.ApprovedAdd.approved)
  return approved_;
}
inline void ApprovedAdd::set_approved(bool value) {
  
  approved_ = value;
  // @@protoc_insertion_point(field_set:models.ApprovedAdd.approved)
}

// -------------------------------------------------------------------

// CancelRequest

// string RobotID = 1;
inline void CancelRequest::clear_robotid() {
  robotid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CancelRequest::robotid() const {
  // @@protoc_insertion_point(field_get:models.CancelRequest.RobotID)
  return robotid_.GetNoArena();
}
inline void CancelRequest::set_robotid(const ::std::string& value) {
  
  robotid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:models.CancelRequest.RobotID)
}
#if LANG_CXX11
inline void CancelRequest::set_robotid(::std::string&& value) {
  
  robotid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:models.CancelRequest.RobotID)
}
#endif
inline void CancelRequest::set_robotid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  robotid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:models.CancelRequest.RobotID)
}
inline void CancelRequest::set_robotid(const char* value, size_t size) {
  
  robotid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:models.CancelRequest.RobotID)
}
inline ::std::string* CancelRequest::mutable_robotid() {
  
  // @@protoc_insertion_point(field_mutable:models.CancelRequest.RobotID)
  return robotid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CancelRequest::release_robotid() {
  // @@protoc_insertion_point(field_release:models.CancelRequest.RobotID)
  
  return robotid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CancelRequest::set_allocated_robotid(::std::string* robotid) {
  if (robotid != NULL) {
    
  } else {
    
  }
  robotid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), robotid);
  // @@protoc_insertion_point(field_set_allocated:models.CancelRequest.RobotID)
}

// .models.CancelOrder CancellingOrder = 2;
inline bool CancelRequest::has_cancellingorder() const {
  return this != internal_default_instance() && cancellingorder_ != NULL;
}
inline const ::models::CancelOrder& CancelRequest::_internal_cancellingorder() const {
  return *cancellingorder_;
}
inline const ::models::CancelOrder& CancelRequest::cancellingorder() const {
  const ::models::CancelOrder* p = cancellingorder_;
  // @@protoc_insertion_point(field_get:models.CancelRequest.CancellingOrder)
  return p != NULL ? *p : *reinterpret_cast<const ::models::CancelOrder*>(
      &::models::_CancelOrder_default_instance_);
}
inline ::models::CancelOrder* CancelRequest::release_cancellingorder() {
  // @@protoc_insertion_point(field_release:models.CancelRequest.CancellingOrder)
  
  ::models::CancelOrder* temp = cancellingorder_;
  cancellingorder_ = NULL;
  return temp;
}
inline ::models::CancelOrder* CancelRequest::mutable_cancellingorder() {
  
  if (cancellingorder_ == NULL) {
    auto* p = CreateMaybeMessage<::models::CancelOrder>(GetArenaNoVirtual());
    cancellingorder_ = p;
  }
  // @@protoc_insertion_point(field_mutable:models.CancelRequest.CancellingOrder)
  return cancellingorder_;
}
inline void CancelRequest::set_allocated_cancellingorder(::models::CancelOrder* cancellingorder) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(cancellingorder_);
  }
  if (cancellingorder) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cancellingorder = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cancellingorder, submessage_arena);
    }
    
  } else {
    
  }
  cancellingorder_ = cancellingorder;
  // @@protoc_insertion_point(field_set_allocated:models.CancelRequest.CancellingOrder)
}

// -------------------------------------------------------------------

// ApprovedCancel

// .models.CancelRequest CancelledRequest = 1;
inline bool ApprovedCancel::has_cancelledrequest() const {
  return this != internal_default_instance() && cancelledrequest_ != NULL;
}
inline void ApprovedCancel::clear_cancelledrequest() {
  if (GetArenaNoVirtual() == NULL && cancelledrequest_ != NULL) {
    delete cancelledrequest_;
  }
  cancelledrequest_ = NULL;
}
inline const ::models::CancelRequest& ApprovedCancel::_internal_cancelledrequest() const {
  return *cancelledrequest_;
}
inline const ::models::CancelRequest& ApprovedCancel::cancelledrequest() const {
  const ::models::CancelRequest* p = cancelledrequest_;
  // @@protoc_insertion_point(field_get:models.ApprovedCancel.CancelledRequest)
  return p != NULL ? *p : *reinterpret_cast<const ::models::CancelRequest*>(
      &::models::_CancelRequest_default_instance_);
}
inline ::models::CancelRequest* ApprovedCancel::release_cancelledrequest() {
  // @@protoc_insertion_point(field_release:models.ApprovedCancel.CancelledRequest)
  
  ::models::CancelRequest* temp = cancelledrequest_;
  cancelledrequest_ = NULL;
  return temp;
}
inline ::models::CancelRequest* ApprovedCancel::mutable_cancelledrequest() {
  
  if (cancelledrequest_ == NULL) {
    auto* p = CreateMaybeMessage<::models::CancelRequest>(GetArenaNoVirtual());
    cancelledrequest_ = p;
  }
  // @@protoc_insertion_point(field_mutable:models.ApprovedCancel.CancelledRequest)
  return cancelledrequest_;
}
inline void ApprovedCancel::set_allocated_cancelledrequest(::models::CancelRequest* cancelledrequest) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cancelledrequest_;
  }
  if (cancelledrequest) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cancelledrequest = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cancelledrequest, submessage_arena);
    }
    
  } else {
    
  }
  cancelledrequest_ = cancelledrequest;
  // @@protoc_insertion_point(field_set_allocated:models.ApprovedCancel.CancelledRequest)
}

// bool approved = 2;
inline void ApprovedCancel::clear_approved() {
  approved_ = false;
}
inline bool ApprovedCancel::approved() const {
  // @@protoc_insertion_point(field_get:models.ApprovedCancel.approved)
  return approved_;
}
inline void ApprovedCancel::set_approved(bool value) {
  
  approved_ = value;
  // @@protoc_insertion_point(field_set:models.ApprovedCancel.approved)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace models

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::models::RobotStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::models::RobotStatus>() {
  return ::models::RobotStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_messages_5frm_2eproto
